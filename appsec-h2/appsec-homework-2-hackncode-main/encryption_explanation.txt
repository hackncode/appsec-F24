Encryption Implementation

In this project, I implemented encryption for sensitive card data using the djfernet library in Django. The main objective was to ensure that any data saved in the database could not be directly accessed or seen without proper authorization, enhancing the security of the application. To achieve this, I replaced the original field definition for the card data with EncryptedTextField() in the models. This modification allowed the data to be encrypted automatically when stored in the database, which provided an extra layer of security.

A major part of this implementation involved managing the encryption keys effectively. Instead of embedding the key directly in the source code (which would be insecure and make the key vulnerable to exposure), I opted to store the key in an environment file. This way, it is only accessible through the system’s environment settings. I used Python’s dotenv package to load these keys securely, allowing me to access the key via environment variables while keeping it separated from the codebase.

Once the encryption was set up, I needed to make changes to how encrypted card data was handled in the program logic. Encryption with djfernet is non-deterministic, which means I couldn't use raw queries or rely on Django’s ORM to match encrypted values directly. To work around this, I modified the logic in the views by fetching all card objects from the database and iterating over them to find a match for the requested card. This process was slightly more cumbersome but necessary to maintain the security of the encrypted data while still allowing legitimate operations on it.

For key management, I considered a few different approaches. The key could have been hardcoded directly into the application, but this would have made it vulnerable to being accessed if the source code was leaked. Alternatively, storing keys in a dedicated vault like HashiCorp Vault could have provided a high level of security but at the cost of increased complexity and infrastructure requirements. I found that storing the keys as environment variables provided a good balance between security and practicality. This way, the key isn't hardcoded in the application, reducing the risk of exposure, while still being straightforward to access during application initialization. The keys are managed using the environment file, accessed through the dotenv package.

To make sure the encryption was working as intended, I added tests to the Django application and integrated them into a GitHub Actions CI/CD pipeline. This setup allowed automated verification of the encryption implementation each time new code was pushed. The tests covered scenarios like buying and using gift cards to ensure that the encrypted data could still be used correctly by the system. GitHub Actions helped maintain the integrity of the implementation and caught any regressions or issues introduced by future changes.

Overall, implementing encryption with djfernet and managing keys securely using environment variables allowed me to significantly improve the security posture of the application. By making the necessary adjustments to handle encrypted data within the program logic, I ensured that the application remained functional without compromising on security.
